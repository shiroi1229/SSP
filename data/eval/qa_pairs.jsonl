{"id": "eval_rag_connectivity", "query": "RAGエンジンがPostgreSQL接続エラーを起こしたときの確認ポイントは？", "expected_answer": "環境変数で指定したPostgreSQLのホスト/ポート/DB/ユーザー/パスワードを確認し、`modules.rag_engine.RAGEngine._refresh_pg_connection`の再接続ログと例外を確認する。接続できない場合はサービス再起動と資格情報の再読み込みを行う。", "ground_truth_contexts": ["RAGEngineは初期化時にPostgreSQL接続を開き、失敗時はログに例外と接続不可メッセージを残す", "接続情報は環境変数（POSTGRES_HOST/PORT/DB/USER/PASSWORD）とconfig_managerから読み込まれる", "_refresh_pg_connectionで再接続が行われ、失敗するとRAGは利用不可としてログに記録される"], "retrieved_contexts": ["modules.rag_engine.RAGEngineは初期化時にPostgreSQLへ接続し、例外時は`RAGEngine initialization error`をログに出す", "_refresh_pg_connectionで接続をリフレッシュし、成功すると`PostgreSQL connection refreshed`を記録する", "接続に失敗すると`RAGEngine is not available`を返す安全装置がある", "knowledge APIではRAGEngineが利用不可の場合503を返す"], "model_answer": "環境変数に設定したPostgreSQLの資格情報が正しいか確認し、`_refresh_pg_connection`のログで再接続が成功しているかを見る。RAGEngineが利用不可になった場合はサービス再起動で設定を読み直す。", "tags": ["rag", "operations", "postgres"]}
{"id": "eval_knowledge_search", "query": "Knowledge検索APIでRAGコンテキストが空になるときに調べるべき箇所は？", "expected_answer": "`backend/api/knowledge.py`の`/knowledge/search`で例外が出ていないかを確認し、`rag.search`が返すitems件数をログに残す。RAGEngineが利用不可の場合はHTTP 500が返るので、先にRAGエンジンの状態とQdrantの接続性を点検する。", "ground_truth_contexts": ["backend/api/knowledge.pyの/knowledge/searchはrag.searchを呼び出し、例外時にHTTP 500を返す", "検索結果はログとして`type: knowledge_search`と件数が記録される", "rag.searchが利用不可の場合は例外が投げられる"], "retrieved_contexts": ["/knowledge/searchエンドポイントはrag.searchでQdrantを検索し、例外時は500を返す", "ログにはquery, limit, returned件数が記録される", "list_knowledgeではorder_byがscoreまたはcreated_atに制限される", "ingest_knowledgeは空テキストで400、チャンクが0件なら503を返す"], "model_answer": "`/knowledge/search`でrag.searchが例外を出すと500が返るので、まずRAGエンジンとQdrant接続を確認する。APIは検索件数をknowledge_searchログに残すので、returnedが0になっていないかを見て空の原因を特定する。", "tags": ["rag", "api", "backend"]}
{"id": "eval_feedback_logging", "query": "ユーザー評価をRAG再学習に活用するための既存ログはどれか？", "expected_answer": "`data/feedback_log.json`にsession_id・rating・feedbackが蓄積されており、`modules.rag_engine.reinforce_rag_with_feedback`の入力に使える。高スコア応答をRAGに登録する際はratingとコメントを付けて最適化ログに保存する。", "ground_truth_contexts": ["data/feedback_log.jsonに評価スコアと自由記述が残る", "rag_engine内のreinforce_rag_with_feedbackで高評価応答をRAGへ登録する処理がある", "最適化ログは評価結果と応答テキストを含めて保存される"], "retrieved_contexts": ["feedback_log.jsonにはsession_id, rating, feedbackが格納される", "rag_engine.reinforce_rag_with_feedbackは高スコア回答をRAGにupsertする", "evaluate_outputは評価結果をoptimization_logに追記する", "generatorやschedulerから評価ジョブが呼び出される"], "model_answer": "`data/feedback_log.json`にユーザー評価がまとまっているので、reinforce_rag_with_feedbackで高スコアの応答をupsertできる。評価結果はoptimization_logにも残るため、RAG再学習の入力として使える。", "tags": ["feedback", "rag", "learning"]}
{"id": "eval_scheduler_hooks", "query": "週次ジョブでRAG関連のタスクが走らない場合、どの設定を確認する？", "expected_answer": "`orchestrator/scheduler.py`の`schedule.every().monday`や`sunday`で設定されたジョブが有効かを確認し、run_jobに渡す関数（reinforce_rag_with_feedbackや自動最適化）が読み込まれているかを見る。BACKEND_API_URLなどの環境変数も指定されている必要がある。", "ground_truth_contexts": ["scheduler.pyはscheduleライブラリで曜日・時間ごとのジョブを登録する", "RAG強化や最適化ジョブはrun_jobでラップされ、例外はログに残る", "BACKEND_API_URLは自己分析レポート生成API呼び出しで使われる"], "retrieved_contexts": ["scheduler.start_schedulerで毎日/毎週のジョブを登録する", "reinforce_rag_with_feedbackやoptimize_rag_memoryが定期実行される", "run_jobは開始・完了・失敗をlog_scheduler_eventで記録する", "BACKEND_API_URLは週次自己分析レポート生成に使われる"], "model_answer": "`orchestrator/scheduler.py`でscheduleに登録されているRAGジョブ（reinforce_rag_with_feedbackやoptimize_rag_memory）が有効かを確認する。run_jobのログに失敗が出ていないか、BACKEND_API_URLなど必要な環境変数が設定されているかもチェックする。", "tags": ["scheduler", "rag", "operations"]}
{"id": "eval_context_window", "query": "RAGコンテキストの長さを抑える既存設定はどこにある？", "expected_answer": "`modules/generator.py`と`modules/evaluator.py`に`MAX_RAG_CONTEXT_CHARS`があり、rag_contextを同じ長さで切り詰めている。ContextManagerにセットする際もこの上限を使う。", "ground_truth_contexts": ["modules/generator.pyとmodules/evaluator.pyでMAX_RAG_CONTEXT_CHARSが4000に設定されている", "rag_contextは_bounded_textで上限文字数に丸められる", "Evaluatorはrag_contextを短くしてからLLMへ評価を依頼する"], "retrieved_contexts": ["generator.pyでrag_contextを_bounded_textで4000文字に収める", "evaluator.pyも同じMAX_RAG_CONTEXT_CHARSでrag_contextを切り詰める", "評価スコアはContextManagerに保存される", "rag_engineはcontext取得時にログを出力する"], "model_answer": "GeneratorとEvaluatorの両方にMAX_RAG_CONTEXT_CHARS=4000があり、_bounded_textでrag_contextを短縮している。長すぎるコンテキストはContextManagerに入る前に切り詰められるため、ここを調整すれば上限を変更できる。", "tags": ["rag", "context", "safety"]}