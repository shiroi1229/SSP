# path: scripts/sync_contracts.py
# version: v1
# Reads the generated openapi.json and creates TypeScript type definitions.

import json
from pathlib import Path
import re

def snake_to_pascal(snake_case_string: str) -> str:
    """Converts a snake_case or kebab-case string to PascalCase."""
    return ''.join(word.capitalize() for word in re.split('_|-', snake_case_string))

def json_type_to_ts_type(prop: dict) -> str:
    """Converts a JSON schema type to a TypeScript type."""
    json_type = prop.get("type")
    if json_type == "string":
        # Could add more specific checks, e.g., for date-time
        return "string"
    elif json_type == "integer" or json_type == "number":
        return "number"
    elif json_type == "boolean":
        return "boolean"
    elif json_type == "array":
        items = prop.get("items", {})
        item_type = json_type_to_ts_type(items)
        # If the item type is complex (an object), it might need a proper interface name
        if "properties" in items:
             # For simplicity, we'll use a generic object array for now.
             # A more advanced version could generate nested interfaces.
            return "Record<string, unknown>[]"
        return f"{item_type}[]"
    elif json_type == "object":
        # For nested objects, a more robust solution would generate separate interfaces.
        # For now, we use a generic Record type.
        return "Record<string, unknown>"
    return "unknown"

def generate_typescript_interface(schema_name: str, schema_dict: dict) -> str:
    """Generates a TypeScript interface string from a JSON schema."""
    if not schema_dict or "properties" not in schema_dict:
        return ""

    interface_name = snake_to_pascal(schema_name)
    ts_string = f"export interface {interface_name} {{\n"
    
    properties = schema_dict.get("properties", {})
    required_fields = schema_dict.get("required", [])

    for prop_name, prop_details in properties.items():
        ts_type = json_type_to_ts_type(prop_details)
        is_optional = prop_name not in required_fields
        ts_string += f"  {prop_name}{'?' if is_optional else ''}: {ts_type} | null;\n"
    
    ts_string += "}\n\n"
    return ts_string

def sync_contracts():
    """Main function to read the schema and generate TS types."""
    project_root = Path(__file__).parent.parent
    schema_path = project_root / "data" / "schemas" / "openapi.json"
    output_dir = project_root / "frontend" / "types"
    
    output_dir.mkdir(exist_ok=True)
    print(f"üöÄ Starting contract sync...")
    print(f"Reading schema from: {schema_path}")
    print(f"Output directory: {output_dir}")

    try:
        with open(schema_path, "r", encoding="utf-8") as f:
            api_schema = json.load(f)
    except (IOError, json.JSONDecodeError) as e:
        print(f"‚ùå Error reading or parsing {schema_path}: {e}")
        return

    # Group schemas by tag to write them to the same file
    schemas_by_file: dict[str, dict[str, dict]] = {}

    for endpoint in api_schema:
        tags = endpoint.get("tags", [])
        tag = tags[0] if tags else "general" # Safely get the first tag or default to "general"
        filename = f"{tag}.ts"

        if filename not in schemas_by_file:
            schemas_by_file[filename] = {}

        if endpoint.get("input_schema"):
            schema_name = endpoint["input_schema"].get("title", f"{endpoint['id']}_input")
            schemas_by_file[filename][schema_name] = endpoint["input_schema"]
        
        if endpoint.get("output_schema"):
            schema_name = endpoint["output_schema"].get("title", f"{endpoint['id']}_output")
            # Handle cases where output is a list
            if endpoint["output_schema"].get("type") == "array":
                 item_schema = endpoint["output_schema"].get("items", {})
                 item_schema_name = item_schema.get("title", f"{endpoint['id']}_item")
                 schemas_by_file[filename][item_schema_name] = item_schema
            else:
                 schemas_by_file[filename][schema_name] = endpoint["output_schema"]


    # Write the generated interfaces to files
    for filename, schemas in schemas_by_file.items():
        output_path = output_dir / filename
        all_interfaces = f"// Auto-generated by scripts/sync_contracts.py\n\n"
        
        # Avoid duplicate interfaces
        generated_names = set()
        for schema_name, schema_dict in schemas.items():
            if schema_name not in generated_names:
                all_interfaces += generate_typescript_interface(schema_name, schema_dict)
                generated_names.add(schema_name)

        try:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(all_interfaces)
            print(f"‚úÖ Synced types to {output_path}")
        except IOError as e:
            print(f"‚ùå Error writing to {output_path}: {e}")

if __name__ == "__main__":
    sync_contracts()
